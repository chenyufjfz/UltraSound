`timescale 1ns / 1ps

/*
Input Ram, e.g.
0 Len = 2
1 Read addr a
2 Write addr b
3 bh
4 bl
Output Ram, e.g.
0 Read addr a
1 ah
2 al
3 Write addr b
*/
module execcmd(
    //input
    clk,    
    clk_2,
    rst,    

    //input command ram
    inram_address,
    inram_re,
    inram_q,

    //output result ram
    outram_address,
    outram_we,
    outram_d,

    //AXI reg access
    reg_addr_c2,
    reg_rd_c2,
    reg_wr_c2,
    reg_ready_c2,
    reg_writedata_c2,
    reg_readdata_c2,

    //controller
    start_exec,
    busy,
    err,
    out_len
);
parameter AW=10;
localparam CMD_WRITE = 2'b10;
localparam CMD_READ = 2'b00;

    //input
    input           clk;
    input           clk_2;
    input           rst;    
    
    //input command ram
    output reg [AW-1:0] inram_address;
    output reg          inram_re;
    input [15:0]        inram_q;

    //output result ram
    output reg [AW-1:0] outram_address;
    output reg          outram_we;
    output reg [15:0]   outram_d;

    //internal AXI reg access
    output [13:0]       reg_addr_c2;
    output              reg_rd_c2;
    output              reg_wr_c2;
    input               reg_ready_c2;
    output [31:0]       reg_writedata_c2;
    input [31:0]        reg_readdata_c2;

    //controller
    input               start_exec;
    output reg          busy;
    output reg          err;
    output reg [AW-1:0] out_len;

    //internal AXI reg access
    reg [13:0]          reg_addr;
    reg                 reg_rd;
    reg                 reg_wr;
    wire                reg_ready;
    wire [31:0]         reg_writedata;
    wire [31:0]         reg_readdata;
    
    //internal reg
    reg [1:0]           command;
    reg [15:0]          in_len;
    reg [15:0]          reg_writedata_h, reg_writedata_l;
    wire                check_length;

    assign check_length = (inram_address < in_len &&  outram_address < 800);
    assign reg_writedata = {reg_writedata_h, reg_writedata_l};
    
    reg_dec_rate #(14) reg_dec_rate_inst(
        //clock & reset
        .clk                (clk),
        .clk_2              (clk_2),
        .rst                (rst),
        
        //slave, fast clock domain
        .reg_s_addr         (reg_addr),
        .reg_s_rd           (reg_rd),
        .reg_s_wr           (reg_wr),
        .reg_s_ready        (reg_ready),
        .reg_s_writedata    (reg_writedata),
        .reg_s_readdata     (reg_readdata),
        
        //master, slow clock domain
        .reg_m_addr         (reg_addr_c2),
        .reg_m_rd           (reg_rd_c2),
        .reg_m_wr           (reg_wr_c2),
        .reg_m_ready        (reg_ready_c2),
        .reg_m_writedata    (reg_writedata_c2),
        .reg_m_readdata     (reg_readdata_c2)
    );

    always
    begin : cmd_process
        @(posedge clk);
        inram_address <= #1 0;
        outram_address <= #1 0;
        inram_re <= #1 0;
        outram_we <= #1 0;
        busy <= #1 0;
        in_len <= #1 0;
        while (!start_exec) //dowhile
            @(posedge clk);
        inram_re <= #1 1;
        busy <= #1 1;
        @(posedge clk);
        inram_address <= #1 1;
        @(posedge clk);
        in_len <= #1 inram_q;
        @(posedge clk);
        while (check_length)
        begin
            @(posedge clk);
            reg_addr <= #1 inram_q[13:0];
            command <= #1 inram_q[15:14];
            outram_d <= #1 inram_q;
            outram_we <= #1 1;
            inram_address <= #1 inram_address + 1'b1;
            @(posedge clk);
            outram_we <= #1 0;
            outram_address <= #1 outram_address + 1'b1;
            if (command == CMD_WRITE)
            begin
                inram_address <= #1 inram_address + 1'b1;
                @(posedge clk);
                reg_writedata_h <= #1 inram_q;
                inram_address <= #1 inram_address + 1'b1;                
                @(posedge clk);
                reg_wr <= #1 1;
                reg_writedata_l <= #1 inram_q;
                while (!reg_ready) //dowhile
                    @(posedge clk);
                reg_wr <= #1 0;
            end
            else
            if (command == CMD_READ)
            begin
                reg_rd <= #1 1;
                while (!reg_ready) //dowhile
                    @(posedge clk);
                reg_rd <= #1 0;
                outram_d <= #1 reg_readdata[31:16];
                outram_we <= 1;
                @(posedge clk);
                outram_d <= #1 reg_readdata[15:0];
                outram_address <= #1 outram_address + 1'b1;
                @(posedge clk);
                outram_address <= #1 outram_address + 1'b1;
                outram_we <= 0;
            end
        end
        @(posedge clk);
        if (in_len == inram_address)
        begin
            err <= #1 0;
            out_len <= #1 outram_address;
        end
        else
        begin
            err <= #1 1;
            out_len <= #1 0;
        end
    end

    always
    begin : SYNC_RESET
        @(posedge clk);
        if (rst)
        begin
            outram_we <= #1 0;
            reg_rd <= #1 0;
            reg_wr <= #1 0;
            err <= #1 0;
            busy <= #1 0;
            disable cmd_process;
        end
    end
endmodule